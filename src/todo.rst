todo
################################################################################

興味を持った点と疑問点
================================================================================

(1) A base compiler(full-codegen)が生成したコード
--------------------------------------------------------------------------------

  どんなコードを吐くのか。JavaScript初心者なので、どんな汎用的なコードに落ちるのか興味あります。

>> full-codegenでcodeを参照して大まかには理解できた。
   uninisializeなICをひたすら生成してあるく。らしい。
   ICの中身はV8でAsmを叩いて生成している。

  V8は再帰関数がxxx monkeyと比較して速いという話を聞いたことがあったので、
  full-codegenが関数をstab越しに呼び出す際に何らかのトリックを使っていそう。

>> code cacheの仕組みであったり、ICがよくできているのだと思う。
  恐らくだが、V8祭りの記事を熟読すれば理解できるはず

  hot codeを判断するため、runtimeと連携してprofileを取得する命令をfull-codegenは埋め込むはず。
  遅延を最小にする工夫と、どんなprofile情報を取得しているのか。

>> どこでやっているのか不明。
  恐らくだが、uninisialized ICの中で行っているはず。

  現時点での予想としては、load/storeのICの中で行っているのかも。
  その結果を型推論して、operand returnに伝搬していくのかもしれない。
  binaryopやunaryのICに仕組みは入っていないのかもしれない。

  データの中身は、テーブルで持っているのだと思う。


(2) Crankshaftが生成したコード
--------------------------------------------------------------------------------

  crankshaftは最も高速なコードを生成するはずで、どんなコードを吐くのか。

>> --print_codeの結果を参照して大まかには理解できた。
  smi/heapの違いに着目すれば、大体のコードは追えている。
  基本的には、smiをguardして、高速なコードを生成していくはず。
  smiをtype-stableにコーディングするかぎり、非常に高速に動作するはず。
  追加の疑問点として、
    stringを使用した場合、どのようにguardするのか。stringaddが高速らしい。ropeのアルゴリズムの使用。
    smiのguardが冗長に思うのだが、asmで叩いているのが原因のように思う。
    その辺を速い段階でmacro expandして、何らかの最適化をかければ、冗長なコードを除去できるように思う。
    macroのexpandなのか、レイヤーの追加なのか。
    JVMと、llvmのlazy value infoとcorrepsed value propagationを使用すれば改善できる可能性がある。
    実際にコーディングしてみるか？
    また、実際になぜ冗長なguardが生成されているのか、その原因を調査する。

  deoptimizeが発生後、full-codegenへ戻るが、その後の挙動はどうなるのか。
  たとえば、full-codegenは再度プロファイル情報を取得しながらCrankshaftでのJITコンパイルの機会を伺うのか、
  同じ関数のCrankshaftでのJITコンパイルに上限を設けるのか。
  profile情報を落としてfull-codegenでコンパイルを行い、ずっとfull-codegenで実行するのか。

>> 未調査

  inliningの仕組み。たとえば、JVMは呼び出し候補が複数ある場合、かつ第1候補が9割の確率で呼ばれる場合、
  第1候補をinliningする。CrankshaftがStabコードのまま扱うのか、inliningする条件が気になる。

>> 調査途中の奴が、optimizeに記述しているはず

  runtime profilerで型情報に関する情報を取得し、型推論した上でCrankshaftでJITコンパイルするはず。
  aggressiveに型推論した場合の保証コード+Trapの有無と、型推論の実装はどうなっているのか。

>> smiのケースは、普通にguardするだけ。

  型推論の結果をどのように適用するのか。ASTレベルなのかHIRレベルなのか。

>> ASTからhydrogenへの変換持に、type-feedback-oracleによって、ASTへ簡単な型推論の情報を戻しているように思う。
  load/storeに限定してだが。
  型推論は、type-infe-initializeで行っており、
  operand-typeやresult-typeの型をforwardingして伝搬していくようなアルゴリズムになっている。
  伝搬してoperandtypeやresulttypeが確定したのち、冗長な型チェックを除去するパスが走る。
  追加の疑問点
    smi以外のケースや、確定していないケースにおいて、どのようなコードを生成するのかどうか。
    ICに頼るのか？ICもuninitialize以外に多数存在したので、genericなICを生成するのかもしれない。
    typefeedback oracleの結果は、具体的にどのように活用されるのか。crankshaftでrecompileした際に使うように思うが、
    そもそも異なる型だからこそ、craqnkshaftからdeoptimizeされ、
    またrecompileされるため、そこでtype-feedback-oraleが活用されるのかもしれない。
    テストするための具体的なコードを作成したい。


  JVM HotSpot C1の生成したコードとどっちが速いか。

>> 未調査。
  type-stableにコーディングする限り、かなり高速な印象。
  また、loop-invariant-code-motionの有無やStringAddのため、C1より高速なコードを生成できるはず。

(3) hot codeのコンパイルの判断
--------------------------------------------------------------------------------

  最初にfull-codegenで生成したコードを実行し、hot codeだと判断したら、
  CrankshaftでJITコンパイルするはず。
  hot codeだと判断する条件は、しきい値以上に呼び出される関数であるかどうか、
  しきい値以上に実行されるループのどちらかのはず。

  hot codeであると判断する上で、runtime profilerとどのように連携するのかどうか。

>> 正確なしきい値で表現できないように思う。
  とくに、loopの中でfunctionを何度も呼ぶようなケースでは、
  inline展開して、その親関数をCrankshaftでコンパイルしてOSRされるように思う。
  再帰関数の場合はcrankshaftでrecompileされるのだが、
  再帰でないケースは、Crankshftでコンパイルさせるのは難しい。 

(4) Crankshaftの中間表現とコンパイルパイプラインのデザインに関して
--------------------------------------------------------------------------------

  SSA形式といっても、色々あるので、どんな中間表現なのか。

>> 中間表現の構造は、graphベースでphiはnodeとして表現されていない。
  内部のアルゴリズムも、C2のIdealみたいに動作する。
  すべてがC2のIdealみたいに細かい粒度の命令ではなく、
  StringAddやICが混在した状態で動作することを前提としているため、
  ところどころかなり粒度の粗いmacroが入っている。

  OSR/Deoptimizeの仕組み。 Tableの仕組みやSafecodeに関して。

>> 未調査

  Profile情報の、JavaScript固有の活用方法

>> 大体わかったはず。
  型情報をspecrativeに使って、高速なコードを生成していく

(5) 追加の宿題

  typeinference-initialize

  hydrogenの本格的な構造の調査

  lithiumの構造の調査と、lithiumの最適化アルゴリズムの調査

  調査結果をsphinxでまとめるのはいいとして、順番に構造化したい。
  sphinxのrstをファイルで分割して、うまく構造化するための方法を調査し、
  blogファイルをメインとして、調査を追加していくような使い方をしたい。
  トップダウンのケースにおいて、うまいまとめかたがあるのかどうか。


================================================================================

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


================================================================================
================================================================================
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


################################################################################
================================================================================
--------------------------------------------------------------------------------
